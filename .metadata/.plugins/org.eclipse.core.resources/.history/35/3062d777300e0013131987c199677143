package Partitioning;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.AbstractQueue;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Queue;

import android.R.bool;
import android.R.integer;
import android.R.string;
import android.webkit.WebChromeClient.CustomViewCallback;
import Common.*;

public class DBScan {

	/*
	 * Parameters for deciding weather two pictures are "close" to each other as
	 * part of the DBScan algorithm
	 */
	private final double MaxSecondsInterval = 600;
	private final double MaxMetersInterval = 50;
	private final int minNumberOfPointsInCluster = 2;

	private Hashtable<Double, PhotoObjectForClustering> unvisitedPhotos = null;
	private Hashtable<Double, PhotoObjectForClustering> visitedPhotos = null;

	public DBScan(List<Photo> photosData) {
		PhotoObjectForClustering tempObject;
		unvisitedPhotos = new Hashtable<Double, PhotoObjectForClustering>();
		if (photosData != null) {
			for (Photo p : photosData) {
				if (p != null) {
					tempObject = new PhotoObjectForClustering(p);
					unvisitedPhotos.put(p.getID(), tempObject);
				}
			}
		}
		visitedPhotos = new Hashtable<Double, PhotoObjectForClustering>();
	}

	public List<Cluster> runAlgorithmClusters() {
		List<Cluster> clustersList = new LinkedList<Cluster>();
		PhotoObjectForClustering arbitraryUnvisitedPhoto;
		while (!unvisitedPhotos.isEmpty()) {
			arbitraryUnvisitedPhoto = getArbitraryPhotoFromHashTableClustering(unvisitedPhotos);
			moveToVisited(arbitraryUnvisitedPhoto);
			Queue<PhotoObjectForClustering> neighborsList = regionQueryList(arbitraryUnvisitedPhoto);
			if (neighborsList.size() < minNumberOfPointsInCluster) {
				arbitraryUnvisitedPhoto.isNoise = true;
			} else {
				Cluster cluster = new Cluster();
				clustersList.add(cluster);
				arbitraryUnvisitedPhoto.addPointToCluster(cluster);
				expandCluster(cluster, arbitraryUnvisitedPhoto, neighborsList);
			}
		}
		return clustersList;
	}

	private void expandCluster(Cluster c, PhotoObjectForClustering p,
			Queue<PhotoObjectForClustering> neighbors) {
		if (neighbors != null) {
			Queue<PhotoObjectForClustering> subNeighborsList;

			PhotoObjectForClustering neighbor;
			while (!neighbors.isEmpty()) {
				neighbor = neighbors.remove();
				if (!neighbor.isVisited) {
					moveToVisited(neighbor);
					subNeighborsList = regionQueryList(neighbor);
					if ((subNeighborsList != null)
							&& (subNeighborsList.size() >= minNumberOfPointsInCluster)) {
						neighbors.addAll(subNeighborsList);
					}
				}
				if (neighbor.cluster == null) {
					p.addPointToCluster(c);
				}
			}
		}
	}

	private void moveToVisited(PhotoObjectForClustering p) {
		p.isVisited = true;
		unvisitedPhotos.remove(p.getID());
		visitedPhotos.put(p.getID(), p);
	}

	private boolean isEpsilonDistanced(PhotoObjectForClustering p1,
			PhotoObjectForClustering p2) {
		if ((p1.distanceFrom(p2) < MaxMetersInterval)
				&& (p1.timeDeltaInSecondsFrom(p2) < MaxSecondsInterval))
			return true;
		return false;
	}

	private Queue<PhotoObjectForClustering> regionQueryList(
			PhotoObjectForClustering p) {
		Queue<PhotoObjectForClustering> photosEpsilonClose = new PriorityQueue<PhotoObjectForClustering>();
		for (PhotoObjectForClustering photoCandidate : unvisitedPhotos.values()) {
			if (isEpsilonDistanced(p, photoCandidate)) {
				photosEpsilonClose.add(photoCandidate);
			}

		}
		for (PhotoObjectForClustering photoCandidate : visitedPhotos.values()) {
			if (isEpsilonDistanced(p, photoCandidate)) {
				photosEpsilonClose.add(photoCandidate);
			}
		}
		return photosEpsilonClose;
	}

	private PhotoObjectForClustering getArbitraryPhotoFromHashTableClustering(
			Hashtable<Double, PhotoObjectForClustering> hashTable) {
		if ((hashTable == null) || (hashTable.isEmpty())) {
			return null;
		}
		double tempKey = hashTable.keys().nextElement();
		return hashTable.get(tempKey);
	}

	/*
	 * this function is only for testing issues. it enables us to re-save the
	 * pictures according to clustreing desicion
	 */

	public Boolean savePicturesAccordingToClusters(List<Cluster> clustersList,
			String memoryPathInDevice) {
		String subDirectoryPathString;
		String newFilePathString;
		if ((clustersList == null) || (clustersList.isEmpty()))
			return false;
		Integer i = 1;
		try {
			for (Cluster cluster : clustersList) {
				subDirectoryPathString = memoryPathInDevice + "Cluetser" + i.toString();
				File directoryFile = new File(subDirectoryPathString);
				
				directoryFile.mkdir();
				if ((cluster == null) || (cluster.photosInCluster == null)
						|| (cluster.photosInCluster.isEmpty()))
					return false;
				for (Photo photo : cluster.photosInCluster) {
					if (photo == null)
						return false;
					newFilePathString = subDirectoryPathString + File.separator
							+ photo.getPhotoFile().getName();
					savePhotoToMemory(photo, newFilePathString);
				}
				i++;
			}
		} catch (Exception c) {
			return false;
		}
		return true;
	}

	private Boolean savePhotoToMemory(Photo p, String newFilePath) {
		File originalFile;
		File destionationFile;
		try {

			originalFile = p.getPhotoFile();
			if (originalFile == null)
				return false;
			destionationFile = new File(newFilePath);
			if (destionationFile.createNewFile() == false)
				return false;
			copyFile(originalFile, destionationFile);
			return true;
		} catch (Exception c) {
			return false;
		}
	}

	private void copyFile(File src, File dst) throws IOException {
		InputStream in = new FileInputStream(src);
		OutputStream out = new FileOutputStream(dst);

		// Transfer bytes from in to out
		byte[] buf = new byte[1024];
		int len;
		while ((len = in.read(buf)) > 0) {
			out.write(buf, 0, len);
		}
		in.close();
		out.close();
	}

}

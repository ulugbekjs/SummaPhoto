package Exnternals;

import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.List;


import Common.*;

public class DBScanExternals {

	/*
	 * Parameters for deciding weather two pictures are "close" to each other as
	 * part of the DBScan algorithm
	 */
	private final double MaxSecondsInterval = 600;
	private final double MaxMetersInterval = 50;
	private final int minNumberOfPointsInCluster = 2;

	private Hashtable<Double, PhotoObjectForClusteringExternals> unvisitedPhotos = null;
	private Hashtable<Double, PhotoObjectForClusteringExternals> visitedPhotos = null;

	public DBScanExternals(List<Photo> photosData) {
		PhotoObjectForClusteringExternals tempObject;
		unvisitedPhotos = new Hashtable<Double, PhotoObjectForClusteringExternals>();
		if (photosData != null) {
			for (Photo p : photosData) {
				if (p != null)
				{
				tempObject = new PhotoObjectForClusteringExternals(p);
				unvisitedPhotos.put(p.getID(), tempObject);
				}
			}
		}
		visitedPhotos = new Hashtable<Double, PhotoObjectForClusteringExternals>();
	}

	public List<Cluster> runAlgorithmClusters() {
		List<Cluster> clustersList = new LinkedList<Cluster>();
		PhotoObjectForClusteringExternals arbitraryUnvisitedPhoto;
		while (!unvisitedPhotos.isEmpty()) {
			arbitraryUnvisitedPhoto = getArbitraryPhotoFromHashTableClustering(unvisitedPhotos);
			moveToVisited(arbitraryUnvisitedPhoto);
			List<PhotoObjectForClusteringExternals> neighborsList = regionQueryList(arbitraryUnvisitedPhoto);
			if (neighborsList.size() < minNumberOfPointsInCluster) {
				arbitraryUnvisitedPhoto.isNoise = true;
			} 
			else {
				Cluster cluster = new Cluster();
				clustersList.add(cluster);
				arbitraryUnvisitedPhoto.addPointToCluster(cluster);
				expandCluster(cluster, arbitraryUnvisitedPhoto, neighborsList);
			}
		}
		return clustersList;
	}

	private void expandCluster(Cluster c, PhotoObjectForClusteringExternals p,
			List<PhotoObjectForClusteringExternals> neighbors) {
		if (neighbors != null) {
			List<PhotoObjectForClusteringExternals> subNeighborsList;
			for (PhotoObjectForClusteringExternals neighbor : neighbors) {
				if (!neighbor.isVisited) {
					moveToVisited(neighbor);
					subNeighborsList = regionQueryList(neighbor);
					if ((subNeighborsList != null)
							&& (subNeighborsList.size() >= minNumberOfPointsInCluster)) {
						neighbors.addAll(subNeighborsList);
					}
				}
				if (neighbor.cluster == null) {
					p.addPointToCluster(c);
				}
			}
		}
	}

	private void moveToVisited(PhotoObjectForClusteringExternals p) {
		p.isVisited = true;
		unvisitedPhotos.remove(p.getID());
		visitedPhotos.put(p.getID(), p);
	}

	private boolean isEpsilonDistanced(PhotoObjectForClusteringExternals p1,
			PhotoObjectForClusteringExternals p2) {
		if ((p1.distanceFrom(p2) < MaxMetersInterval)
				&& (p1.timeDeltaInSecondsFrom(p2) < MaxSecondsInterval))
			return true;
		return false;
	}

	private List<PhotoObjectForClusteringExternals> regionQueryList(
			PhotoObjectForClusteringExternals p) {
		List<PhotoObjectForClusteringExternals> photosEpsilonClose = new LinkedList<PhotoObjectForClusteringExternals>();
		for (PhotoObjectForClusteringExternals photoCandidate : unvisitedPhotos.values()) {
			if (isEpsilonDistanced(p, photoCandidate)) {
				photosEpsilonClose.add(photoCandidate);
			}

		}
		for (PhotoObjectForClusteringExternals photoCandidate : visitedPhotos.values()) {
			if (isEpsilonDistanced(p, photoCandidate)) {
				photosEpsilonClose.add(photoCandidate);
			}
		}
		return photosEpsilonClose;
	}

	private PhotoObjectForClusteringExternals getArbitraryPhotoFromHashTableClustering (Hashtable<Double, PhotoObjectForClusteringExternals> hashTable)
	{
		if ((hashTable == null)|| (hashTable.isEmpty()))
		{
			return null;
		}
		double tempKey = hashTable.keys().nextElement();
		return hashTable.get(tempKey);
	}
}
